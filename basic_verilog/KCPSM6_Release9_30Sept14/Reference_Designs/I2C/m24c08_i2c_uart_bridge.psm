                     ;
                     ;------------------------------------------------------------------------------------------
                     ; Copyright © 2011-2013, Xilinx, Inc.
                     ; This file contains confidential and proprietary information of Xilinx, Inc. and is
                     ; protected under U.S. and international copyright and other intellectual property laws.
                     ;------------------------------------------------------------------------------------------
                     ;
                     ; Disclaimer:
                     ; This disclaimer is not a license and does not grant any rights to the materials
                     ; distributed herewith. Except as otherwise provided in a valid license issued to
                     ; you by Xilinx, and to the maximum extent permitted by applicable law: (1) THESE
                     ; MATERIALS ARE MADE AVAILABLE "AS IS" AND WITH ALL FAULTS, AND XILINX HEREBY
                     ; DISCLAIMS ALL WARRANTIES AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY,
                     ; INCLUDING BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-INFRINGEMENT,
                     ; OR FITNESS FOR ANY PARTICULAR PURPOSE; and (2) Xilinx shall not be liable
                     ; (whether in contract or tort, including negligence, or under any other theory
                     ; of liability) for any loss or damage of any kind or nature related to, arising
                     ; under or in connection with these materials, including for any direct, or any
                     ; indirect, special, incidental, or consequential loss or damage (including loss
                     ; of data, profits, goodwill, or any type of loss or damage suffered as a result
                     ; of any action brought by a third party) even if such damage or loss was
                     ; reasonably foreseeable or Xilinx had been advised of the possibility of the same.
                     ;
                     ; CRITICAL APPLICATIONS
                     ; Xilinx products are not designed or intended to be fail-safe, or for use in any
                     ; application requiring fail-safe performance, such as life-support or safety
                     ; devices or systems, Class III medical devices, nuclear facilities, applications
                     ; related to the deployment of airbags, or any other applications that could lead
                     ; to death, personal injury, or severe property or environmental damage
                     ; (individually and collectively, "Critical Applications"). Customer assumes the
                     ; sole risk and liability of any use of Xilinx products in Critical Applications,
                     ; subject only to applicable laws and regulations governing limitations on product
                     ; liability.
                     ;
                     ; THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS PART OF THIS FILE AT ALL TIMES.
                     ;
                     ;------------------------------------------------------------------------------------------
                     ;
                     ;
                     ;             _  ______ ____  ____  __  __  __
                     ;            | |/ / ___|  _ \/ ___||  \/  |/ /_
                     ;            | ' / |   | |_) \___ \| |\/| | '_ \
                     ;            | . \ |___|  __/ ___) | |  | | (_) )
                     ;            |_|\_\____|_|   |____/|_|  |_|\___/
                     ;
                     ;
                     ; KCPSM6 reference design: I2C Communication with M24C08 EEPROM device on the KC705 board
                     ;                          which also requires control of a PCA9548 I2C Bus Switch.
                     ;
                     ;
                     ;
                     ; Ken Chapman - Xilinx Ltd
                     ;
                     ; 12th October 2012 - Initial version
                     ;   18th March 2013 - Constant directives defining ASCII control characters removed
                     ;                     (pre-defined in KCPSM6 assembler v2.43 or later).
                     ;
                     ;
                     ;
                     ; INTRODUCTION
                     ;
                     ; The primary purpose of this reference design is to illustrate how KCPSM6 can implement
                     ; the signaling and protocol required to communicate and control an I2C bus and devices.
                     ;
                     ; The design is based on the standard reference designs provided with KCPSM6 (PicoBlaze).
                     ; These provide a UART-USB connection allowing messages to be displayed on a terminal and
                     ; for keyboard entries to allow a degree of control and data input. Please refer to the
                     ; documentation provided with KCPSM6 and the UART macros if you need to know more about
                     ; PicoBlaze and UART communication. PicoTerm is also supplied with KCPSM6 and ideally
                     ; suited to this application so please use it.
                     ;
                     ; In this example, the aim is to communicate with the M24C08 EEPROM device on the KC705
                     ; board. Due to the arrangement on the KC705 board this also requires the selection
                     ; of 'CH3' on the PCA9548 I2C Bus Switch to which the EEPROM is connected. As such, this
                     ; program is actually an example of communication with two I2C devices which hopefully
                     ; makes it more realistic, interesting and educational. Please see 'kc705_i2c_devices.psm'
                     ; for more details of the I2C arrangement and routines that communicate with these devices.
                     ;
                     ; The hardware defines a classic 2-wire I2C interface ready for serial communication.
                     ;
                     ;    i2c_clk    Clock
                     ;    i2c_data   Data
                     ;
                     ; Both signals are bi-directional. One KCPSM6 output port is used to control the output
                     ; drive ('open collector' style outputs can be driven Low or tri-stated). One KCPSM6
                     ; input port is used to read the states of both signals. Absolutely everything related
                     ; to the generation of I2C signals and the communication protocol is implemented by
                     ; KCPSM6 and defined within the PSM files provided (detailed descriptions are provided
                     ; in the PSM code).
                     ;
                     ; Please be aware that this program also generates a pulse to the hardware reset
                     ; control on the PCA9548 device using one constant output port. This is not really part
                     ; of the I2C signaling but can help to recover from any bus fault conditions that may
                     ; occur when experimenting with the KC705 board.
                     ;
                     ; This program is only intended to provide a simple example of communication with the
                     ; EEPROM device. The terminal (PicoTerm) provides a convenient way to interact with the
                     ; design and a useful way to develop and verify EEPROM memory operations. In most real
                     ; applications there is no compelling reason to retain the UART sections and certainly
                     ; the I2C code has no dependence on the UART related code.
                     ;
                     ; The M24C08 is an 8k-bit EEPROM memory organised as 1024 bytes. This means that it
                     ; has a 10-bit address (range 000 to 3FF hex). In this PSM file the 10-bit address
                     ; handling is easily handled using a pair or registers. However. the way in which the
                     ; 10-bit addresses are communicated to the M24C08 is less obvious. You might be
                     ; interested to review the implementation and descriptions provided with the
                     ; relevant routines contained in 'kc705_i2c_devices.psm' (or maybe you are just
                     ; happy to accept that the low level details have already been covered for you).
                     ;
                     ;
                     ; NOTE - This PSM file includes further PSM files so these must also be present
                     ;        when running the KCPSM6 assembler (v2.00 or later). It is hoped that the
                     ;        included files will also be suitable for reuse and inclusion in your own
                     ;        programs. For this reason each file contains descriptions of the routines
                     ;        that are provided.
                     ;
                     ;                  i2c_routines.psm - A set of routines to implement fundamental
                     ;                                     I2C signaling.
                     ;
                     ;             kc705_i2c_devices.psm - A set of routines which implement I2C transactions
                     ;                                     with some of the devices on the KC705 board
                     ;                                     including the PCA9548 and M24C08 which are the
                     ;                                     focus of this design.
                     ;
                     ;             PicoTerm_routines.psm - A set of routines to interface with the UART
                     ;                                     macros and use the PicoTerm features.
                     ;
                     ;            soft_delays_100mhz.psm - Software delays based on 100MHz clock frequency.
                     ;
                     ;
                     ;------------------------------------------------------------------------------------------
                     ; Port definitions
                     ;------------------------------------------------------------------------------------------
                     ;
                     ;
                     ; UART (for connection with PicoTerm)
                     ; -----------------------------------
                     ;
                     ; See 'PicoTerm_routines.psm' for I/O ports used with UART macros.
                     ;
                     ;
                     ; I2C Interface
                     ; -------------
                     ;
                     ; See 'kc705_i2c_devices.psm' for I/O ports used for I2C communication.
                     ;
                     ;
                     ; PCA9548 (I2C Bus Switch) Control
                     ; --------------------------------
                     ;
                     ; The PCA9548 has a hardware reset that is active Low. KCPSM6 can control this signal
                     ; with a constant-optimised output port.
                     ;
                     CONSTANT PCA9548_control_port, 02
                     CONSTANT PCA9548_reset_b, 00000001'b
                     ;
                     ;
                     ;------------------------------------------------------------------------------------------
                     ; Special Register usage
                     ;------------------------------------------------------------------------------------------
                     ;
                     ; No registers are given special names in this program.
                     ;
                     ;
                     ;------------------------------------------------------------------------------------------
                     ; Scratch Pad Memory Locations (256 Bytes)
                     ;------------------------------------------------------------------------------------------
                     ;
                     ; Scratch pad memory can be reduced to 64 or 128 bytes if desired.
                     ;
                     ;
                     ; PicoTerm features
                     ; -----------------
                     ;
                     ; See 'PicoTerm_routines.psm' for allocation of 18 memory locations.
                     ; These are currently set to memory locations 00 to 12 hex inclusive.
                     ;
                     ;
                     ;------------------------------------------------------------------------------------------
                     ; Useful data constants
                     ;------------------------------------------------------------------------------------------
                     ;
                     ;
                     ;
                     ;------------------------------------------------------------------------------------------
                     ; Initialise the system
                     ;------------------------------------------------------------------------------------------
                     ;
                     ; A delay of 1 second is implemented which is intended to give time for all the hardware
                     ; to settle into a stable condition before starting to doing anything. This can be
                     ; particularly beneficial when dealing with long cables where serial lines can take some
                     ; time to reach the initial idle state following power being applied.
                     ;
         cold_start: CALL delay_1s
                     ;
                     CALL reset_UART_macros                         ;Reset buffers in UART macros
                     ;
                     CALL I2C_initialise                            ;initialise the I2C bus signals
                     ;
                     ; Generate a hardware reset pulse to the PCA9548 (I2C Bus Switch) to help recover from
                     ; any bus fault conditions that may occur when experimenting with the KC705 board.
                     ;
                     OUTPUTK ~PCA9548_reset_b, PCA9548_control_port ;active Low pulse
                     OUTPUTK PCA9548_reset_b, PCA9548_control_port
                     ;
                     ;
                     ; Initialised PicoTerm display and display welcome messages
                     ;
                     CALL PicoTerm_CLS
                     CALL welcome_message
                     ;
                     ;
                     ;------------------------------------------------------------------------------------------
                     ; Confirm connection has been made with PicoTerm
                     ;------------------------------------------------------------------------------------------
                     ;
                     ; Before attempting to use any of the special features provided by PicoTerm it is a good
                     ; idea to check that PicoTerm really is connected. This is where the Device Control String
                     ; (DCS) request for a 'Ping' can be used. If a different terminal is being used then the
                     ; plain text messages will be displayed as normal but the 'Ping' request will fail to
                     ; return the response expected. So if this should occur a message will be displayed and
                     ; this program will halt.
                     ;
                     ; Calling the 'PicoTerm_Ping' routine will transmit the Device Control String (DCS)
                     ; to request the 'Ping' from PicoTerm. If PicoTerm is connected then it should respond
                     ; with a DCS containing the (upper case) character 'P'. The response will be intercepted
                     ; by the UART_RX routine and stored in scratch pad memory location 'PicoTerm_Response0'.
                     ; It will take a short while for PicoTerm to respond so the 'Ping' check must wait whilst
                     ; repeatedly calling the UART_RX routine.
                     ;
                     ; The transmission and reception of the 'Ping' DCS sequences (6 characters in total) would
                     ; take ~520us at 115,200 baud rate. Since the program is only going to halt if no response
                     ; occurs it will actually wait much longer. Each call of the UART_RX routine that results
                     ; in its timeout will take ~2,000 clock cycles (~20us at 100MHz) so up to 50,000 (C350 hex)
                     ; calls of UART_RX are made before giving up after approximately one second.
                     ;
                     LOAD s0, 00                                    ;clear 'Ping' response location
                     STORE s0, PicoTerm_Response0
                     ;
                     CALL PicoTerm_Ping                             ;request 'Ping' from PicoTerm
                     ;
                     LOAD sB, C3                                    ;wait for 50,000 iterations
                     LOAD sA, 50                                    ;  (~1 second at 100MHz)
                     ;
       wait_PT_ping: CALL UART_RX                                   ;discard any characters received
                     FETCH s0, PicoTerm_Response0
                     COMPARE s0, "P"                                ;Test for valid 'Ping' response
                     JUMP Z, PicoTerm_detected                      ;continue normally
                     SUB sA, 01                                     ;decrement [sB,sA]
                     SUBCY sB, 00
                     JUMP NZ, wait_PT_ping
                     ;
                     ; 'Ping' response not received so transmit a text message.
                     ; Note this would still be displayed on other terminals.
                     ;
                     LOAD sB, no_detect_PT_msg'upper
                     LOAD sA, no_detect_PT_msg'lower
                     CALL send_message
       PT_halt_here: JUMP PT_halt_here                              ;Halt program.
                     ;
                     ;
                     STRING not_PT1$, "ERROR - Unable to detect PicoTerm."
                     STRING not_PT2$, "Please use PicoTerm v1.30 or later with this design."
                     ;
                     ;
   no_detect_PT_msg: LOAD&RETURN s5, CR
                     LOAD&RETURN s5, not_PT1$
                     LOAD&RETURN s5, CR
                     LOAD&RETURN s5, not_PT2$
                     LOAD&RETURN s5, CR
                     LOAD&RETURN s5, NUL
                     ;
                     ; Once 'Ping' has confirmed that PicoTerm is present, close the 'PicoTerm DCS Transactions'
                     ; window so that only the main window is open.
                     ;
  PicoTerm_detected: CALL PicoTerm_hide_DCS
                     ;
                     ;
                     ;------------------------------------------------------------------------------------------
                     ; Confirm I2C communication with M24C08 EEPROM device
                     ;------------------------------------------------------------------------------------------
                     ;
                     ; When an I2C bus master (KCPSM6 in this case) transmits a byte of information, the
                     ; receiving slave device is expected to respond with an acknowledgement bit (ACK).
                     ; Therefore, observing this acknowledgement is a good indication that communication
                     ; is possible with that slave. Of course, failure to observe an acknowledgement
                     ; implies that something has gone wrong!
                     ;
                     ; In this design the objective is for KCPSM6 to communicate with the M24C08 ERPROM
                     ; device. However, on the KC705, the Kintex-7 device only connects directly to a
                     ; PCA9548 Bus Switch and then the M24C08 connects to 'CH3' of that switch. So to
                     ; communicate with the EEPROM, KCPSM6 must first communicate with the Bus Switch
                     ; and select 'CH3'.
                     ;
                     ; This section will first determine if I2C communication with the PCA9548 Bus Switch is
                     ; possible. If it is, 'CH3' will be selected and an attempt will be made to to
                     ; communicate with the M24C08 ERPROM. For the purposes of this reference design
                     ; suitable text messages will be displayed depending on the results.
                     ;
                     ; The routines to communicate with the PCA9548 and the M24C08 devices are contained
                     ; in 'kc705_i2c_devices.psm'. A communication failure is signified by the carry flag
                     ; being set on return from any of these routines.
                     ;
                     ;
                     LOAD sB, I2C_check_msg'upper
                     LOAD sA, I2C_check_msg'lower
                     CALL send_message
                     ;
                     ; Attempt to select 'CH3' on the PCA9548 Bus Switch. Success will confirm
                     ; communication with this device and select the EEPROM. As an additional test
                     ; the channel selection value will be read back from the Bus Switch and
                     ; checked.
                     ;
                     LOAD sB, PCA9548_check_msg'upper
                     LOAD sA, PCA9548_check_msg'lower
                     CALL send_message
                     ;
                     LOAD sD, 00001000'b                            ;'CH3' selection value
                     CALL PCA9548_mux_write                         ;write to PCA9548
                     JUMP C, I2C_failure                            ;comm's failure if carry=1
                     ;
                     CALL PCA9548_mux_read                          ;read back switch control value
                     COMPARE sD, 00001000'b                         ;verify selection of 'CH3'
                     JUMP NZ, I2C_failure
                     ;
                     CALL send_Pass
                     ;
                     ; An attempt is made to read from any memory location of the M24C08 ERPROM. Success
                     ; will confirm communication via the Bus Switch with the EEPROM is possible.
                     ;
                     LOAD sB, M24C08_check_msg'upper
                     LOAD sA, M24C08_check_msg'lower
                     CALL send_message
                     ;
                     LOAD s8, 00                                    ;test address zero in [s8,s7]
                     LOAD s7, 00
                     CALL M24C08_read
                     JUMP C, I2C_failure                            ;comm's failure if carry=1
                     ;
                     CALL send_Pass
                     JUMP M24C08_detected                           ;Everything Ok to continue
                     ;
                     ;
                     ; I2C failure will display a message and halt the program.
                     ;
        I2C_failure: CALL PicoTerm_text_Red
                     LOAD sB, I2C_fail_msg'upper
                     LOAD sA, I2C_fail_msg'lower
                     CALL send_message
      I2C_halt_here: JUMP I2C_halt_here                             ;Halt program.
                     ;
                     ;
                     ; Text messages for this section
                     ;
                     STRING I2C_check$, "Testing I2C communication"
                     STRING PCA9548_check$, "  Bus Switch (PCA9548)... "
                     STRING M24C08_check$, "  1KB EEPROM (M24C08).... "
                     STRING I2C_fail1$, "ERROR - I2C unable to communicate!"
                     STRING I2C_fail2$, "        Please try a complete power cycle of the KC705 board."
                     ;
      I2C_check_msg: LOAD&RETURN s5, CR
                     LOAD&RETURN s5, I2C_check$
                     LOAD&RETURN s5, NUL
                     ;
  PCA9548_check_msg: LOAD&RETURN s5, CR
                     LOAD&RETURN s5, PCA9548_check$
                     LOAD&RETURN s5, NUL
                     ;
   M24C08_check_msg: LOAD&RETURN s5, CR
                     LOAD&RETURN s5, M24C08_check$
                     LOAD&RETURN s5, NUL
                     ;
       I2C_fail_msg: LOAD&RETURN s5, CR
                     LOAD&RETURN s5, CR
                     LOAD&RETURN s5, I2C_fail1$
                     LOAD&RETURN s5, CR
                     LOAD&RETURN s5, I2C_fail2$
                     LOAD&RETURN s5, CR
                     LOAD&RETURN s5, NUL
                     ;
    M24C08_detected: 
                     ;
                     ;
                     ;------------------------------------------------------------------------------------------
                     ; Main Program
                     ;------------------------------------------------------------------------------------------
                     ;
                     ; The 'main' program allows the user to read, write and erase the N25Q128 device.
                     ;
                     ;   WARNING - You are responsible for your own actions!
                     ;
                     ;
     main_with_menu: CALL PicoTerm_text_Blue
                     CALL display_menu
                     ;
                     ; Display prompt and wait for user input.
                     ; Then test input for valid section and either invoke operation or display message.
                     ;
        main_prompt: CALL PicoTerm_text_Blue
                     CALL send_CR                                   ;prompt user to enter a command
                     CALL send_CR
                     LOAD s5, ">"
                     CALL UART_TX
                     CALL send_space
                     ;
          wait_main: CALL UART_RX                                   ;wait for user input
                     JUMP Z, wait_main
                     CALL upper_case                                ;accept upper or lower case inputs
                     CALL UART_TX                                   ;echo user input
                     ;
                     COMPARE s5, "H"                                ;Help
                     JUMP Z, main_with_menu
                     ;
                     COMPARE s5, "R"                                ;Read EEPROM
                     JUMP Z, read_EEPROM_command
                     ;
                     COMPARE s5, "W"                                ;Write Byte
                     JUMP Z, write_byte_command
                     ;
                     LOAD s5, "?"                                   ;For all other inputs display ??
                     CALL UART_TX
                     CALL UART_TX
                     JUMP main_prompt
                     ;
                     ;
                     ;------------------------------------------------------------------------------------------
                     ; 'R' Read 1K Bytes Command
                     ;------------------------------------------------------------------------------------------
                     ;
                     ; Read and display all 1024 bytes of data currently stored in the M24C08 EEPROM.
                     ;
                     ; In order to display all bytes in a way that is easy for the user to interpret, the
                     ; memory map will be segmented into 4 blocks of 256 bytes. These will then be displayed
                     ; in a square so that all information is visible on the screen at the same time.
                     ;
                     ;               000-0FF    200-2FF
                     ;
                     ;               100-1FF    300-3FF
                     ;
                     ; As a further aid, addresses will be displayed in a different colour to the data.
                     ;
                     ; Obviously this takes rather more PSM code to implement than that required simply to
                     ; scan through the EEPROM but it is hoped that all PSM code is a useful example, and more
                     ; significantly, this display does illustrates that EEPROM memory can be randomly accessed.
                     ;
read_EEPROM_command: LOAD sD, 00001000'b                            ;Select PCA9548 'CH3' for M24C08
                     CALL PCA9548_mux_write
                     JUMP C, I2C_failure                            ;comm's failure if carry=1
                     ;
                     ; Display the address offset for each column in the form...   +0 +1 +2 ... +F
                     ;
                     CALL PicoTerm_text_Black
                     CALL send_CR
                     LOAD s8, 00
  column_label_loop: TEST s8, 00001111'b                            ;Test for first column of each block
                     JUMP NZ, column_space
                     CALL send_space                                ;spaces to align with first column
                     CALL send_space
                     CALL send_space
                     CALL send_space
                     CALL send_space
                     CALL send_space
                     CALL send_space
                     CALL send_space
       column_space: CALL send_space
                     LOAD s5, "+"                                   ;display '+'
                     CALL UART_TX
                     LOAD s5, s8                                    ;convert lower nibble of 's8' to ASCII
                     AND s5, 00001111'b
                     CALL hex_to_ASCII
                     CALL UART_TX                                   ;display digit
                     ADD s8, 01
                     COMPARE s8, 20
                     JUMP NZ, column_label_loop
                     CALL send_CR
                     ;
                     ; Each line will of the display will contain 16 bytes from two blocks.
                     ;   On the left side of the screen is the address range 000 to 1FF.
                     ;   On the right side of the screen is the address range 200 to 3FF.
                     ;
                     ; So starting with address 000, the first line reads and displays EEPROM data from
                     ; 000 to 00F on the left hand side. It then skips to address 200 and reads and displays
                     ; EEPROM data from 200 to 20F on the right hand side. Once the first line is complete
                     ; the address skips back to 010 ready to being the second line.
                     ;
                     LOAD s7, 00                                    ;10-bit EEPROM address in [s8,s7]
                     LOAD s8, 00
                     ;
  line_display_loop: CALL send_CR
                     COMPARE s7, 00                                 ;add a line space before the start of the
                     COMPARECY s8, 01                               ;lower blocks starting at address 100
                     JUMP NZ, begin_line
                     CALL send_CR
         begin_line: CALL send_space
                     CALL send_space
                     CALL send_space
                     CALL send_space
                     ;
                     ; Left Side
                     ; Display address of first byte in black
                     ;
                     CALL PicoTerm_text_Black                       ;display 10-bit address
                     LOAD s5, s8                                    ;convert lower nibble of 's8' to ASCII
                     CALL hex_to_ASCII
                     CALL UART_TX                                   ;display MS-digit
                     LOAD s4, s7                                    ;convert and display two LS-Digits
                     CALL send_hex_byte
                     CALL send_space
                     CALL send_space
                     ;
                     ; Left Side
                     ; Read and display 16 bytes of EEPROM data in Magenta
                     ;
                     CALL PicoTerm_text_Magenta
     left_side_loop: CALL M24C08_read                               ;read from [s8,s7] into 'sD'
                     JUMP C, I2C_failure                            ;comm's failure if carry=1
                     LOAD s4, sD                                    ;display byte
                     CALL send_hex_byte
                     CALL send_space
                     ADD s7, 01                                     ;increment address
                     ADDCY s8, 00
                     TEST s7, 00001111'b                            ;test rollover of 16th byte
                     JUMP NZ, left_side_loop
                     ;
                     ; Right Side
                     ; Display address of first byte in black
                     ;
                     ADD s7, F0                                     ;Advance address by 200-010 hex
                     ADDCY s8, 01
                     CALL send_space
                     CALL send_space
                     CALL send_space
                     CALL PicoTerm_text_Black                       ;display 10-bit address
                     LOAD s5, s8                                    ;convert lower nibble of 's8' to ASCII
                     CALL hex_to_ASCII
                     CALL UART_TX                                   ;display MS-digit
                     LOAD s4, s7                                    ;convert and display two LS-Digits
                     CALL send_hex_byte
                     CALL send_space
                     CALL send_space
                     ;
                     ; Right Side
                     ; Read and display 16 bytes of EEPROM data in Magenta
                     ;
                     CALL PicoTerm_text_Magenta
    right_side_loop: CALL M24C08_read                               ;read from [s8,s7] into 'sD'
                     JUMP C, I2C_failure                            ;comm's failure if carry=1
                     LOAD s4, sD                                    ;display byte
                     CALL send_hex_byte
                     CALL send_space
                     ADD s7, 01                                     ;increment address
                     ADDCY s8, 00
                     TEST s7, 00001111'b                            ;test rollover of 16th byte
                     JUMP NZ, right_side_loop
                     ;
                     ; Test for reaching the end of EEPROM memory.
                     ; Last EEPROM address is 3FF so test for rollover to 0400.
                     ;
                     COMPARE s8, 04
                     JUMP Z, main_prompt                            ;jump to main program when complete
                     ;
                     SUB s8, 02                                     ;retard address by 200 hex
                     JUMP line_display_loop                         ;display next left side
                     ;
                     ;
                     ;------------------------------------------------------------------------------------------
                     ; 'W' Write Byte Command
                     ;------------------------------------------------------------------------------------------
                     ;
                     ; Obtain a 10-bit address and 8-bit data value from the user and then write to EEPROM
                     ; memory.
                     ;
 write_byte_command: LOAD sD, 00001000'b                            ;Select PCA9548 'CH3' for M24C08
                     CALL PCA9548_mux_write
                     JUMP C, I2C_failure                            ;comm's failure if carry=1
                     ;
                     CALL obtain_address                            ;10-bit address in [s8,s7]
                     CALL obtain_data                               ;8-bit data value in sD
                     ;
                     CALL M24C08_write                              ;write 'sD' into [s8,s7]
                     ;
                     JUMP C, I2C_failure                            ;comm's failure if carry=1
                     ;
                     CALL PicoTerm_text_Green
                     CALL send_Ok
                     JUMP main_prompt
                     ;
                     ;
                     ;------------------------------------------------------------------------------------------
                     ; Obtain 10-bit address from user
                     ;------------------------------------------------------------------------------------------
                     ;
                     ; Prompt user to enter a 10-bit address and return it in [s8,s7].
                     ; If user makes a mistake then keep prompting until they get it right!
                     ;
     obtain_address: CALL PicoTerm_text_Black
                     LOAD sB, prompt_address_msg'upper              ;prompt for address
                     LOAD sA, prompt_address_msg'lower
                     CALL send_message
                     ;
                     LOAD sE, 3'd                                   ;obtain 3-digit value
                     CALL obtain_value                              ;12-bit value returned in [sB,sA]
                     JUMP C, bad_address_input                      ;Carry set for a bad hex value
                     ;
                     TEST sB, 11111100'b                            ;check only 10-bit range
                     JUMP NZ, bad_address_input
                     ;
                     LOAD s8, sB                                    ;return 10-bit address
                     LOAD s7, sA                                    ;  in return it in [s8,s7]
                     RETURN 
                     ;
  bad_address_input: CALL PicoTerm_text_Red
                     LOAD sB, bad_address_msg'upper
                     LOAD sA, bad_address_msg'lower
                     CALL send_message
                     JUMP obtain_address
                     ;
                     ;
                     ; Text messages used in this section
                     ;
                     STRING prompt_address$, "Please enter a 10-bit (3-digit hexadecimal) address  > "
                     STRING bad_address$, "Sorry, that was not a valid address in the range 000 to 3FF hex!"
                     ;
 prompt_address_msg: LOAD&RETURN s5, CR
                     LOAD&RETURN s5, CR
                     LOAD&RETURN s5, prompt_address$
                     LOAD&RETURN s5, NUL
                     ;
    bad_address_msg: LOAD&RETURN s5, CR
                     LOAD&RETURN s5, bad_address$
                     LOAD&RETURN s5, NUL
                     ;
                     ;
                     ;------------------------------------------------------------------------------------------
                     ; Obtain 8-bit data from user
                     ;------------------------------------------------------------------------------------------
                     ;
                     ; Prompt user to enter an 8-bit data byte and return it in 'sD'.
                     ; If user makes a mistake then keep prompting until they get it right!
                     ;
        obtain_data: CALL PicoTerm_text_Black
                     LOAD sB, prompt_data_msg'upper                 ;prompt for address
                     LOAD sA, prompt_data_msg'lower
                     CALL send_message
                     ;
                     LOAD sE, 2'd                                   ;obtain 2-digit value
                     CALL obtain_value                              ;8-bit value returned in sA
                     JUMP C, bad_data_input                         ;Carry set for a bad hex value
                     LOAD sD, sA                                    ;Return data value in 'sD'
                     RETURN 
                     ;
     bad_data_input: CALL PicoTerm_text_Red
                     LOAD sB, bad_data_msg'upper
                     LOAD sA, bad_data_msg'lower
                     CALL send_message
                     JUMP obtain_data
                     ;
                     ;
                     ; Text messages used in this section
                     ;
                     STRING prompt_data$, "Please enter an 8-bit data (2-digit hexadecimal) value > "
                     STRING bad_data$, "Sorry, that was not a valid 2-digit hexadecimal value!"
                     ;
    prompt_data_msg: LOAD&RETURN s5, CR
                     LOAD&RETURN s5, CR
                     LOAD&RETURN s5, prompt_data$
                     LOAD&RETURN s5, NUL
                     ;
       bad_data_msg: LOAD&RETURN s5, CR
                     LOAD&RETURN s5, bad_data$
                     LOAD&RETURN s5, NUL
                     ;
                     ;
                     ;------------------------------------------------------------------------------------------
                     ; Welcome Message.
                     ;------------------------------------------------------------------------------------------
                     ;
                     ; The welcome message includes a display of the version information available from the
                     ; assembler and the 'hwbuild' from the instantiation of KCPSM6 in the hardware design.
                     ;
    welcome_message: LOAD sB, welcome_msg'upper
                     LOAD sA, welcome_msg'lower
                     CALL send_message
                     HWBUILD s5                                     ;hardware version defines ASCII letter
                     CALL UART_TX
                     CALL send_CR
                     RETURN 
                     ;
                     ; Welcome message
                     ;
                     STRING banner1$, "  _  ______ ____  ____  __  __  __"
                     STRING banner2$, " | |/ / ___|  _ \/ ___||  \/  |/ /_"
                     STRING banner3$, " | ' / |   | |_) \___ \| |\/| | '_ \"
                     STRING banner4$, " | . \ |___|  __/ ___) | |  | | (_) )"
                     STRING banner5$, " |_|\_\____|_|   |____/|_|  |_|\___/"
                     ;
                     ; Welcome message
                     ;
                     STRING welcome1$, "Reference Design: M24C08 EEPROM Controller for KC705 Board"
                     STRING welcome2$, "                  KCPSM6 implements an I2C 'Master'"
                     STRING welcome3$, "Assembly Date: "
                     STRING welcome4$, "   Time: "
                     STRING welcome5$, "Assembler Version: "
                     STRING welcome6$, "Hardware Design: "
                     ;
                     ;
        welcome_msg: LOAD&RETURN s5, banner1$
                     LOAD&RETURN s5, CR
                     LOAD&RETURN s5, banner2$
                     LOAD&RETURN s5, CR
                     LOAD&RETURN s5, banner3$
                     LOAD&RETURN s5, CR
                     LOAD&RETURN s5, banner4$
                     LOAD&RETURN s5, CR
                     LOAD&RETURN s5, banner5$
                     LOAD&RETURN s5, CR
                     LOAD&RETURN s5, CR
                     LOAD&RETURN s5, welcome1$
                     LOAD&RETURN s5, CR
                     LOAD&RETURN s5, welcome2$
                     LOAD&RETURN s5, CR
                     LOAD&RETURN s5, CR
                     LOAD&RETURN s5, welcome3$
                     LOAD&RETURN s5, datestamp$
                     LOAD&RETURN s5, welcome4$
                     LOAD&RETURN s5, timestamp$
                     LOAD&RETURN s5, CR
                     LOAD&RETURN s5, welcome5$
                     LOAD&RETURN s5, KCPSM6_version$
                     LOAD&RETURN s5, CR
                     LOAD&RETURN s5, welcome6$
                     LOAD&RETURN s5, NUL
                     ;
                     ;
                     ;------------------------------------------------------------------------------------------
                     ; Routine to transmit a simple 'Menu'.
                     ;------------------------------------------------------------------------------------------
                     ;
       display_menu: LOAD sB, menu_msg'upper
                     LOAD sA, menu_msg'lower
                     CALL send_message
                     RETURN 
                     ;
                     ; Menu message
                     ;
                     STRING menu1$, "Menu"
                     STRING menu2$, " H - Display this menu"
                     STRING menu3$, " R - Read (all 1K Bytes)"
                     STRING menu4$, " W - Write (Byte)"
                     ;
           menu_msg: LOAD&RETURN s5, CR
                     LOAD&RETURN s5, CR
                     LOAD&RETURN s5, menu1$
                     LOAD&RETURN s5, CR
                     LOAD&RETURN s5, menu2$
                     LOAD&RETURN s5, CR
                     LOAD&RETURN s5, menu3$
                     LOAD&RETURN s5, CR
                     LOAD&RETURN s5, menu4$
                     LOAD&RETURN s5, CR
                     LOAD&RETURN s5, NUL
                     ;
                     ;
                     ;------------------------------------------------------------------------------------------
                     ; Send a message to the UART
                     ;------------------------------------------------------------------------------------------
                     ;
                     ; A message is transmitted to the USB-UART.
                     ; The start address of the message must be provided in [sB,sA].
                     ; Terminate the transmission with a NULL character (00 hex).
                     ;
       send_message: CALL@ (sB, sA)
                     COMPARE s5, 00                                 ;terminate on NUL character
                     RETURN Z
                     CALL UART_TX
                     ADD sA, 1'd
                     ADDCY sB, 0'd
                     JUMP send_message
                     ;
                     ;
                     ;------------------------------------------------------------------------------------------
                     ; Send Carriage Return to UART
                     ;------------------------------------------------------------------------------------------
                     ;
                     ; Registers used s0, s1, s2, and s5.
                     ;
            send_CR: LOAD s5, CR
                     JUMP UART_TX                                   ;includes RETURN
                     ;
                     ;
                     ;------------------------------------------------------------------------------------------
                     ; Send Carriage Return, 'Ok' and Carriage Return to UART
                     ;------------------------------------------------------------------------------------------
                     ;
                     ; Registers used s0, s1, s2, and s5.
                     ;
            send_Ok: CALL send_CR
                     LOAD s5, "O"
                     CALL UART_TX
                     LOAD s5, "k"
                     CALL UART_TX
                     JUMP send_CR                                   ;includes RETURN
                     ;
                     ;
                     ;------------------------------------------------------------------------------------------
                     ; Send 'Pass' to UART
                     ;------------------------------------------------------------------------------------------
                     ;
                     ; Registers used s0, s1, s2, and s5.
                     ;
          send_Pass: LOAD s5, "P"
                     CALL UART_TX
                     LOAD s5, "a"
                     CALL UART_TX
                     LOAD s5, "s"
                     CALL UART_TX
                     JUMP UART_TX                                   ;includes RETURN
                     ;
                     ;------------------------------------------------------------------------------------------
                     ; Send a Space to UART
                     ;------------------------------------------------------------------------------------------
                     ;
                     ; Registers used s0, s1, s2, and s5.
                     ;
         send_space: LOAD s5, " "
                     JUMP UART_TX                                   ;includes RETURN
                     ;
                     ;
                     ;------------------------------------------------------------------------------------------
                     ; Send Hex Value of Byte to UART
                     ;------------------------------------------------------------------------------------------
                     ;
                     ; Value provided in register 's4' is sent as ASCII HEX to the UART transmitter.
                     ;
                     ; Registers used s0, s4 (preserved) and s5.
                     ;
      send_hex_byte: LOAD s5, s4                                    ;isolate upper nibble
                     SR0 s5
                     SR0 s5
                     SR0 s5
                     SR0 s5
                     CALL hex_to_ASCII                              ; convert to ASCII
                     CALL UART_TX                                   ;send upper digit to UART
                     LOAD s5, s4                                    ;isolate lower nibble
                     AND s5, 0F
                     CALL hex_to_ASCII                              ; convert to ASCII
                     CALL UART_TX                                   ;send lower digit to UART
                     RETURN 
                     ;
                     ; Convert value 00 to 0F provided in 's5' into ASCII character in 's5'
                     ;
                     ; Register used s5
                     ;
       hex_to_ASCII: SUB s5, 0A                                     ;test if value is in range 0 to 9
                     JUMP C, number_char
                     ADD s5, 07                                     ;ASCII char A to F in range 41 to 46
        number_char: ADD s5, 3A                                     ;ASCII char 0 to 9 in range 30 to 40
                     RETURN 
                     ;
                     ;
                     ;------------------------------------------------------------------------------------------
                     ; Converts character to upper case
                     ;------------------------------------------------------------------------------------------
                     ;
                     ; Tests and converts character in 's5' (if necessary).
                     ;
                     ; To convert character to upper case
                     ;
                     ; If the character is in the range 'a' to 'z', it is converted
                     ; to the equivalent upper case character in the range 'A' to 'Z'.
                     ; All other characters remain unchanged.
                     ;
         upper_case: COMPARE s5, "a"                                ;eliminate character codes below 'a' (61 hex)
                     RETURN C
                     COMPARE s5, 7B                                 ;eliminate character codes above 'z' (7A hex)
                     RETURN NC
                     AND s5, 11011111'b                             ;force bit5 Low to convert to upper case
                     RETURN 
                     ;
                     ;
                     ;------------------------------------------------------------------------------------------
                     ; Convert ASCII character to an equivalent HEX value.
                     ;------------------------------------------------------------------------------------------
                     ;
                     ; Converts the ASCII character presented in 's5' to an equivalent HEX value.
                     ; If character is not valid for hex, then CARRY is set on return.
                     ;
                     ; Register used s5
                     ;
       ASCII_to_hex: ADD s5, B9                                     ;test for above ASCII code 46 ('F')
                     RETURN C
                     SUB s5, E9                                     ;normalise 0 to 9 with A-F in 11 to 16 hex
                     RETURN C                                       ;reject below ASCII code 30 ('0')
                     SUB s5, 11                                     ;isolate A-F down to 00 to 05 hex
                     JUMP NC, ASCII_letter
                     ADD s5, 07                                     ;test for above ASCII code 46 ('F')
                     RETURN C
                     SUB s5, F6                                     ;convert to range 00 to 09
                     RETURN 
       ASCII_letter: ADD s5, 0A                                     ;convert to range 0A to 0F
                     RETURN 
                     ;
                     ;
                     ;------------------------------------------------------------------------------------------
                     ; Read ASCII-HEX value up to 8-digits (for 32-bit value) from UART
                     ;------------------------------------------------------------------------------------------
                     ;
                     ; Read up to 8 hex characters from UART and convert to a binary value in the [sD,sC,sB,sA]
                     ; register set. The number of characters to be read must be defined in sE. When less than
                     ; 8 characters are read the value is returned in the least significant bits of the register
                     ; set with the 8-bits above the defined value being zero to ensure ensuring that the upper
                     ; nibble will be zero if an odd number of digits are read.
                     ;
                     ; If any character received from the UART is not in the range 0 to F then the routine will
                     ; end immediately with the CARRY flag set and this should be checked my the calling process
                     ; upon return.
                     ;
       obtain_value: LOAD sA, 00                                    ;initialise potentially unused bits to zero
       obtain_digit: CALL UART_RX                                   ;wait for a character and return in s5
                     JUMP Z, obtain_digit                           ;continue to wait if timeout occurs
                     CALL UART_TX                                   ;echo character as entered
                     CALL upper_case                                ;convert to upper case if necessary
                     CALL ASCII_to_hex                              ;convert value in s5 to hex nibble
                     RETURN C                                       ;If invalid hex digit then return immediately
                     LOAD s0, 4'd                                   ;shift [sD,sC,sB,sA] left by 4 bits
        build_value: SL0 sA                                         ;  to make space for new digit value
                     SLA sB
                     SLA sC
                     SLA sD
                     SUB s0, 1'd
                     JUMP NZ, build_value
                     OR sA, s5                                      ;merge value of new digit into existing value
                     SUB sE, 01                                     ;count number of digits obtained
                     JUMP NZ, obtain_digit
                     RETURN 
                     ;
                     ;
                     ;------------------------------------------------------------------------------------------
                     ; Include PSM files
                     ;------------------------------------------------------------------------------------------
                     ;
                     ; The INCLUDE directive enables commonly routines to be kept in their own PSM files and
                     ; easily reused in different programs (i.e. avoiding 'cut and paste'). It also allows
                     ; each PSM to remain a more manageable size.
                     ;
                     ;
                     ; Routines that implement interface with UART macros and control PicoTerm.
                     ; ------------------------------------------------------------------------
                     ;
                     INCLUDE "PicoTerm_routines.psm"
                     ;
                     ;
                     ; Software Delays
                     ; ---------------
                     ;
                     INCLUDE "soft_delays_100mhz.psm"
                     ;
                     ;
                     ; Fundamental I2C signaling
                     ; -------------------------
                     ;
                     INCLUDE "i2c_routines.psm"
                     ;
                     ;
                     ; I2C communication with PCA9548 and M24C08 on the KC705 board
                     ; ------------------------------------------------------------
                     ;
                     INCLUDE "kc705_i2c_devices.psm"
                     ;
                     ;
                     ;------------------------------------------------------------------------------------------
                     ; Interrupt Service Routine (ISR)
                     ;------------------------------------------------------------------------------------------
                     ;
                     ; Interrupts are not currently used in this program but in preparation the location of
                     ; the ISR has been defined to corresponding with the 'interrupt_vector' address defined
                     ; in the instantiation of KCPSM6. In this instance the vector is 7F0 hex which means there
                     ; are 16 instructions available before reaching the end of a 2K program memory. Of course
                     ; this can all be modified.
                     ;
                     ADDRESS 7F0
                     ;
                     ;
                ISR: RETURNI DISABLE
                     ;
                     ;
                     ;------------------------------------------------------------------------------------------
                     ; End of Program
                     ;------------------------------------------------------------------------------------------
                     ;
